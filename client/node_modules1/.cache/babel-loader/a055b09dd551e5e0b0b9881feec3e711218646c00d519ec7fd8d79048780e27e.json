{"ast":null,"code":"import { d as _inherits, e as _createSuper, _ as _createClass, a as _classCallCheck, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-67bba7fb.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nvar _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {boolean} opts.lazy\n*/\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n  var _super = _createSuper(MaskedPattern);\n\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, MaskedPattern);\n\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\n    @override\n    @param {Object} opts\n  */\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n      this._rebuildMask();\n    }\n    /** */\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n            if (bName) {\n              // $FlowFixMe no ideas\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                eager: _this.eager,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n          if (_ret === \"continue\") continue;\n        }\n        var char = pattern[i];\n        var isInput = (char in defs);\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n          continue;\n        }\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          isInput = false;\n        }\n        var def = isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          eager: this.eager,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          eager: this.eager,\n          isUnmasking: unmaskingBlock\n        });\n        this._blocks.push(def);\n      }\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n        maskedState = _objectWithoutProperties(state, _excluded);\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFilled;\n      });\n    }\n  }, {\n    key: \"isFixed\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFixed;\n      });\n    }\n  }, {\n    key: \"isOptional\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isOptional;\n      });\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      var _this$_mapPosToBlock;\n      var details = new ChangeDetails();\n      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n      if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n        var d = this._blocks[bi]._appendEager();\n        if (!d.inserted) break;\n        details.aggregate(d);\n      }\n      return details;\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var blockIter = this._mapPosToBlock(this.value.length);\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n      for (var bi = blockIter.index;; ++bi) {\n        var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n        var _block = this._blocks[bi];\n        if (!_block) break;\n        var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n        }));\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n      return chunkTail;\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n          var bDetails = b._appendPlaceholder.apply(b, args);\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n      return details;\n    }\n    /** Finds block in pos */\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n      return removeDetails;\n    }\n    /**\n      @override\n    */\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      if (!this._blocks.length) return 0;\n      var cursor = new PatternCursor(this, cursorPos);\n      if (direction === DIRECTION.NONE) {\n        // -------------------------------------------------\n        // NONE should only go out from fixed to the right!\n        // -------------------------------------------------\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\n        cursor.popState();\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\n        return this.value.length;\n      } // FORCE is only about a|* otherwise is 0\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // try to break fast when *|a\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeFilled();\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n          cursor.popState();\n        } // forward flow\n\n        cursor.pushLeftBeforeInput();\n        cursor.pushLeftBeforeRequired();\n        cursor.pushLeftBeforeFilled(); // backward flow\n\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeInput();\n          cursor.pushRightBeforeRequired();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n        }\n        if (cursor.ok) return cursor.pos;\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos; // cursor.popState();\n        // if (\n        //   cursor.pushRightBeforeInput() &&\n        //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n        //   (!this.lazy || this.extractInput())\n        // ) return cursor.pos;\n\n        return 0;\n      }\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // forward flow\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\n        if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\n\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n      }\n      return cursorPos;\n    }\n    /** Get block by name */\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n  return MaskedPattern;\n}(Masked);\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["d","_inherits","e","_createSuper","_","_createClass","a","_classCallCheck","g","_get","h","_getPrototypeOf","b","_objectWithoutProperties","i","_set","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","_Masked","_super","opts","arguments","length","undefined","definitions","Object","assign","call","DEFAULTS","key","value","_update","prototype","_rebuildMask","_this","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","blocks","_ret","p","slice","bNames","keys","filter","bName","indexOf","sort","maskedBlock","parent","lazy","eager","placeholderChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","get","map","state","set","maskedState","forEach","bi","reset","every","isComplete","isFilled","isFixed","doCommit","reduce","str","unmaskedValue","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_flags$_beforeTailSta2","_block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","_this2","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","_this3","startBlockIter","endBlockIndex","args","bDetails","apply","_value","pos","accVal","_block2","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","name","maskedBlocks","_this4","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["C:/Users/yan rodrigues/Documents/GitHub/Information-Management/client/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import { d as _inherits, e as _createSuper, _ as _createClass, a as _classCallCheck, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-67bba7fb.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nvar _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {boolean} opts.lazy\n*/\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n\n  var _super = _createSuper(MaskedPattern);\n\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern);\n\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\n    @override\n    @param {Object} opts\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              // $FlowFixMe no ideas\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                eager: _this.eager,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n        var isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          isInput = false;\n        }\n\n        var def = isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          eager: this.eager,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          eager: this.eager,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFilled;\n      });\n    }\n  }, {\n    key: \"isFixed\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFixed;\n      });\n    }\n  }, {\n    key: \"isOptional\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isOptional;\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      var _this$_mapPosToBlock;\n\n      var details = new ChangeDetails();\n      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n      if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n\n      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n        var d = this._blocks[bi]._appendEager();\n\n        if (!d.inserted) break;\n        details.aggregate(d);\n      }\n\n      return details;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n        }));\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      if (!this._blocks.length) return 0;\n      var cursor = new PatternCursor(this, cursorPos);\n\n      if (direction === DIRECTION.NONE) {\n        // -------------------------------------------------\n        // NONE should only go out from fixed to the right!\n        // -------------------------------------------------\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\n        cursor.popState();\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\n        return this.value.length;\n      } // FORCE is only about a|* otherwise is 0\n\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // try to break fast when *|a\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeFilled();\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n          cursor.popState();\n        } // forward flow\n\n\n        cursor.pushLeftBeforeInput();\n        cursor.pushLeftBeforeRequired();\n        cursor.pushLeftBeforeFilled(); // backward flow\n\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeInput();\n          cursor.pushRightBeforeRequired();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n        }\n\n        if (cursor.ok) return cursor.pos;\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos; // cursor.popState();\n        // if (\n        //   cursor.pushRightBeforeInput() &&\n        //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n        //   (!this.lazy || this.extractInput())\n        // ) return cursor.pos;\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // forward flow\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\n        if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\n\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
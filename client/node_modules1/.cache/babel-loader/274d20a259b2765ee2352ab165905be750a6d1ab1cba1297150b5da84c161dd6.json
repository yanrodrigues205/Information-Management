{"ast":null,"code":"import { _ as _createClass, a as _classCallCheck, b as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-67bba7fb.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\nvar _excluded = [\"chunks\"];\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _classCallCheck(this, ChunksTailDetails);\n    this.chunks = chunks;\n    this.from = from;\n  }\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && (\n      // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\n      // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n      var details = new ChangeDetails();\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n        if (stop != null && (\n        // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails ||\n          // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n      return details;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n        props = _objectWithoutProperties(state, _excluded);\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      var ci = 0;\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.unshift(chunkShiftPos);\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n        if (shiftChar) return shiftChar;\n      }\n      return '';\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (!this.chunks.length) return '';\n      var ci = this.chunks.length - 1;\n      while (0 <= ci) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shift();\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n        if (shiftChar) return shiftChar;\n      }\n      return '';\n    }\n  }]);\n  return ChunksTailDetails;\n}();\nexport { ChunksTailDetails as default };","map":{"version":3,"names":["_","_createClass","a","_classCallCheck","b","_objectWithoutProperties","ChangeDetails","isString","ContinuousTailDetails","IMask","_excluded","ChunksTailDetails","chunks","arguments","length","undefined","from","key","value","toString","map","String","join","extend","tailChunk","lastChunk","extendLast","stop","push","firstTailChunk","shift","blockIndex","appendTo","masked","MaskedPattern","tail","details","ci","skip","chunk","lastBlockIter","_mapPosToBlock","chunkBlock","index","_stops","indexOf","aggregate","_appendPlaceholder","_blocks","tailDetails","appendTail","_value","inserted","remainChars","slice","rawInserted","append","get","c","state","set","props","Object","assign","cstate","unshift","beforePos","chunkShiftPos","shiftChar","splice","default"],"sources":["C:/Users/yan rodrigues/Documents/GitHub/Information-Management/client/node_modules/imask/esm/masked/pattern/chunk-tail-details.js"],"sourcesContent":["import { _ as _createClass, a as _classCallCheck, b as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-67bba7fb.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nvar _excluded = [\"chunks\"];\n\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new ChangeDetails();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop != null && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n      return details;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, _excluded);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.unshift(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (!this.chunks.length) return '';\n      var ci = this.chunks.length - 1;\n\n      while (0 <= ci) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shift();\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\nexport { ChunksTailDetails as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
import { _ as _slicedToArray } from './_rollupPluginBabelHelpers-089ae9b3.js';
import IMask from 'imask/esm/imask';
import { useRef, useState, useCallback, useEffect } from 'react';

function useIMask(opts) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      onAccept = _ref.onAccept,
      onComplete = _ref.onComplete;

  var ref = useRef(null);
  var maskRef = useRef(null);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      initialized = _useState2[0],
      setInitialized = _useState2[1];

  var _useState3 = useState(''),
      _useState4 = _slicedToArray(_useState3, 2),
      value = _useState4[0],
      setValue = _useState4[1];

  var _useState5 = useState(''),
      _useState6 = _slicedToArray(_useState5, 2),
      unmaskedValue = _useState6[0],
      setUnmaskedValue = _useState6[1];

  var _useState7 = useState(),
      _useState8 = _slicedToArray(_useState7, 2),
      typedValue = _useState8[0],
      setTypedValue = _useState8[1];

  var _destroyMask = useCallback(function () {
    var _maskRef$current;

    (_maskRef$current = maskRef.current) === null || _maskRef$current === void 0 ? void 0 : _maskRef$current.destroy();
    maskRef.current = null;
  }, []);

  var _onAccept = useCallback(function (event) {
    if (!maskRef.current) return;
    setTypedValue(maskRef.current.typedValue);
    setUnmaskedValue(maskRef.current.unmaskedValue);
    setValue(maskRef.current.value);
    onAccept === null || onAccept === void 0 ? void 0 : onAccept(maskRef.current.value, maskRef.current, event);
  }, [onAccept]);

  var _onComplete = useCallback(function () {
    return maskRef.current && (onComplete === null || onComplete === void 0 ? void 0 : onComplete(maskRef.current.value, maskRef.current));
  }, [onComplete]);

  useEffect(function () {
    var el = ref.current;
    if (!el || !(opts !== null && opts !== void 0 && opts.mask)) return _destroyMask();
    var mask = maskRef.current;

    if (!mask) {
      if (el && opts !== null && opts !== void 0 && opts.mask) {
        maskRef.current = IMask(el, opts);

        _onAccept();
      }
    } else {
      mask === null || mask === void 0 ? void 0 : mask.updateOptions(opts);
    }

    setInitialized(Boolean(mask));
  }, [opts, _destroyMask, _onAccept]);
  useEffect(function () {
    if (!maskRef.current) return;
    var mask = maskRef.current;
    mask.on('accept', _onAccept);
    mask.on('complete', _onComplete);
    return function () {
      mask.off('accept', _onAccept);
      mask.off('complete', _onComplete);
    };
  }, [_onAccept, _onComplete]);
  useEffect(function () {
    var mask = maskRef.current;
    if (mask && initialized) mask.value = value;
  }, [value]);
  useEffect(function () {
    var mask = maskRef.current;
    if (mask && initialized) mask.unmaskedValue = unmaskedValue;
  }, [unmaskedValue]);
  useEffect(function () {
    var mask = maskRef.current;
    if (mask && initialized) mask.typedValue = typedValue;
  }, [typedValue]);
  useEffect(function () {
    return _destroyMask;
  }, [_destroyMask]);
  return {
    ref: ref,
    maskRef: maskRef,
    value: value,
    setValue: setValue,
    unmaskedValue: unmaskedValue,
    setUnmaskedValue: setUnmaskedValue,
    typedValue: typedValue,
    setTypedValue: setTypedValue
  };
}

export { useIMask as default };

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('imask'), require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', 'imask', 'react', 'prop-types'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactIMask = {}, global.IMask, global.React, global.PropTypes));
})(this, (function (exports, IMask, React, PropTypes) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var IMask__default = /*#__PURE__*/_interopDefaultLegacy(IMask);
  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var MASK_PROPS = {
    // common
    mask: PropTypes__default["default"].oneOfType([PropTypes__default["default"].array, PropTypes__default["default"].func, PropTypes__default["default"].string, PropTypes__default["default"].instanceOf(RegExp), PropTypes__default["default"].oneOf([Date, Number, IMask__default["default"].Masked]), PropTypes__default["default"].instanceOf(IMask__default["default"].Masked)]),
    value: PropTypes__default["default"].any,
    unmask: PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].oneOf(['typed'])]),
    prepare: PropTypes__default["default"].func,
    validate: PropTypes__default["default"].func,
    commit: PropTypes__default["default"].func,
    overwrite: PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].oneOf(['shift'])]),
    eager: PropTypes__default["default"].bool,
    // events
    onAccept: PropTypes__default["default"].func,
    onComplete: PropTypes__default["default"].func,
    // pattern
    placeholderChar: PropTypes__default["default"].string,
    lazy: PropTypes__default["default"].bool,
    definitions: PropTypes__default["default"].object,
    blocks: PropTypes__default["default"].object,
    // date
    pattern: PropTypes__default["default"].string,
    format: PropTypes__default["default"].func,
    parse: PropTypes__default["default"].func,
    autofix: PropTypes__default["default"].oneOfType([PropTypes__default["default"].bool, PropTypes__default["default"].oneOf(['pad'])]),
    // number
    radix: PropTypes__default["default"].string,
    thousandsSeparator: PropTypes__default["default"].string,
    mapToRadix: PropTypes__default["default"].arrayOf(PropTypes__default["default"].string),
    scale: PropTypes__default["default"].number,
    signed: PropTypes__default["default"].bool,
    normalizeZeros: PropTypes__default["default"].bool,
    padFractionalZeros: PropTypes__default["default"].bool,
    min: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].instanceOf(Date)]),
    max: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].instanceOf(Date)]),
    // dynamic
    dispatch: PropTypes__default["default"].func,
    // ref
    inputRef: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].shape({
      current: PropTypes__default["default"].object
    })])
  };
  var MASK_PROPS_NAMES = Object.keys(MASK_PROPS);
  var NON_MASK_OPTIONS_PROPS_NAMES = ['value', 'unmask', 'onAccept', 'onComplete', 'inputRef'];
  var MASK_OPTIONS_PROPS_NAMES = MASK_PROPS_NAMES.filter(function (pName) {
    return NON_MASK_OPTIONS_PROPS_NAMES.indexOf(pName) < 0;
  });
  // TODO
  // 1. seems like it's wrong to have Opts as only mask options. Other component/input props should also be there. Where is "unmask" prop for instance?
  // 2. Unmask should be infered from Opts (see https://github.com/uNmAnNeR/imaskjs/issues/554#issuecomment-1114014010)
  function IMaskMixin(ComposedComponent) {
    var MaskedComponent = /*#__PURE__*/function (_React$Component) {
      _inherits(MaskedComponent, _React$Component);

      var _super = _createSuper(MaskedComponent);

      function MaskedComponent(props) {
        var _this;

        _classCallCheck(this, MaskedComponent);

        _this = _super.call(this, props);
        _this._inputRef = _this._inputRef.bind(_assertThisInitialized(_this));
        return _this;
      }

      _createClass(MaskedComponent, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (!this.props.mask) return;
          this.initMask();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          var props = this.props;

          var maskOptions = this._extractMaskOptionsFromProps(props);

          if (maskOptions.mask) {
            if (this.maskRef) {
              this.maskRef.updateOptions(maskOptions);
              if ('value' in props) this.maskValue = props.value;
            } else {
              this.initMask(maskOptions);
            }
          } else {
            this.destroyMask();
            if ('value' in props) this.element.value = props.value;
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.destroyMask();
        }
      }, {
        key: "_inputRef",
        value: function _inputRef(el) {
          this.element = el;

          if (this.props.inputRef) {
            if (Object.prototype.hasOwnProperty.call(this.props.inputRef, 'current')) this.props.inputRef.current = el;else this.props.inputRef(el);
          }
        }
      }, {
        key: "initMask",
        value: function initMask() {
          var maskOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._extractMaskOptionsFromProps(this.props);
          this.maskRef = IMask__default["default"](this.element, maskOptions).on('accept', this._onAccept.bind(this)).on('complete', this._onComplete.bind(this));
          if ('value' in this.props) this.maskValue = this.props.value;
        }
      }, {
        key: "destroyMask",
        value: function destroyMask() {
          if (this.maskRef) {
            this.maskRef.destroy();
            delete this.maskRef;
          }
        }
      }, {
        key: "_extractMaskOptionsFromProps",
        value: function _extractMaskOptionsFromProps(props) {
          var cloneProps = Object.assign({}, props); // keep only mask options props

          Object.keys(cloneProps) // TODO why need cast to string?
          .filter(function (prop) {
            return MASK_OPTIONS_PROPS_NAMES.indexOf(prop) < 0;
          }).forEach(function (nonMaskProp) {
            delete cloneProps[nonMaskProp];
          });
          return cloneProps;
        }
      }, {
        key: "_extractNonMaskProps",
        value: function _extractNonMaskProps(props) {
          var cloneProps = Object.assign({}, props);
          MASK_PROPS_NAMES.forEach(function (maskProp) {
            delete cloneProps[maskProp];
          });
          return cloneProps;
        }
      }, {
        key: "maskValue",
        get: function get() {
          if (this.props.unmask === 'typed') return this.maskRef.typedValue;
          if (this.props.unmask) return this.maskRef.unmaskedValue;
          return this.maskRef.value;
        },
        set: function set(value) {
          value = value == null ? '' : value;
          if (this.props.unmask === 'typed') this.maskRef.typedValue = value;else if (this.props.unmask) this.maskRef.unmaskedValue = value;else this.maskRef.value = value;
        }
      }, {
        key: "_onAccept",
        value: function _onAccept(e) {
          if (this.props.onAccept && this.maskRef) this.props.onAccept(this.maskValue, this.maskRef, e);
        }
      }, {
        key: "_onComplete",
        value: function _onComplete(e) {
          if (this.props.onComplete && this.maskRef) this.props.onComplete(this.maskValue, this.maskRef, e);
        }
      }, {
        key: "render",
        value: function render() {
          return React__default["default"].createElement(ComposedComponent, Object.assign({}, this._extractNonMaskProps(this.props), {
            inputRef: this._inputRef
          }));
        }
      }]);

      return MaskedComponent;
    }(React__default["default"].Component);

    var nestedComponentName = ComposedComponent.displayName || ComposedComponent.name || 'Component';
    MaskedComponent.displayName = "IMask(".concat(nestedComponentName, ")");
    MaskedComponent.propTypes = MASK_PROPS;
    return MaskedComponent;
  }

  var _excluded = ["inputRef"];
  var IMaskInputClass = IMaskMixin(function (_ref) {
    var inputRef = _ref.inputRef,
        props = _objectWithoutProperties(_ref, _excluded);

    return React__default["default"].createElement('input', Object.assign({}, props, {
      ref: inputRef
    }));
  });

  var IMaskInputFn = function IMaskInputFn(props, ref) {
    return React__default["default"].createElement(IMaskInputClass, Object.assign({}, props, {
      ref: ref
    }));
  };

  var IMaskInput = React__default["default"].forwardRef(IMaskInputFn);

  function useIMask(opts) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        onAccept = _ref.onAccept,
        onComplete = _ref.onComplete;

    var ref = React.useRef(null);
    var maskRef = React.useRef(null);

    var _useState = React.useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        initialized = _useState2[0],
        setInitialized = _useState2[1];

    var _useState3 = React.useState(''),
        _useState4 = _slicedToArray(_useState3, 2),
        value = _useState4[0],
        setValue = _useState4[1];

    var _useState5 = React.useState(''),
        _useState6 = _slicedToArray(_useState5, 2),
        unmaskedValue = _useState6[0],
        setUnmaskedValue = _useState6[1];

    var _useState7 = React.useState(),
        _useState8 = _slicedToArray(_useState7, 2),
        typedValue = _useState8[0],
        setTypedValue = _useState8[1];

    var _destroyMask = React.useCallback(function () {
      var _maskRef$current;

      (_maskRef$current = maskRef.current) === null || _maskRef$current === void 0 ? void 0 : _maskRef$current.destroy();
      maskRef.current = null;
    }, []);

    var _onAccept = React.useCallback(function (event) {
      if (!maskRef.current) return;
      setTypedValue(maskRef.current.typedValue);
      setUnmaskedValue(maskRef.current.unmaskedValue);
      setValue(maskRef.current.value);
      onAccept === null || onAccept === void 0 ? void 0 : onAccept(maskRef.current.value, maskRef.current, event);
    }, [onAccept]);

    var _onComplete = React.useCallback(function () {
      return maskRef.current && (onComplete === null || onComplete === void 0 ? void 0 : onComplete(maskRef.current.value, maskRef.current));
    }, [onComplete]);

    React.useEffect(function () {
      var el = ref.current;
      if (!el || !(opts !== null && opts !== void 0 && opts.mask)) return _destroyMask();
      var mask = maskRef.current;

      if (!mask) {
        if (el && opts !== null && opts !== void 0 && opts.mask) {
          maskRef.current = IMask__default["default"](el, opts);

          _onAccept();
        }
      } else {
        mask === null || mask === void 0 ? void 0 : mask.updateOptions(opts);
      }

      setInitialized(Boolean(mask));
    }, [opts, _destroyMask, _onAccept]);
    React.useEffect(function () {
      if (!maskRef.current) return;
      var mask = maskRef.current;
      mask.on('accept', _onAccept);
      mask.on('complete', _onComplete);
      return function () {
        mask.off('accept', _onAccept);
        mask.off('complete', _onComplete);
      };
    }, [_onAccept, _onComplete]);
    React.useEffect(function () {
      var mask = maskRef.current;
      if (mask && initialized) mask.value = value;
    }, [value]);
    React.useEffect(function () {
      var mask = maskRef.current;
      if (mask && initialized) mask.unmaskedValue = unmaskedValue;
    }, [unmaskedValue]);
    React.useEffect(function () {
      var mask = maskRef.current;
      if (mask && initialized) mask.typedValue = typedValue;
    }, [typedValue]);
    React.useEffect(function () {
      return _destroyMask;
    }, [_destroyMask]);
    return {
      ref: ref,
      maskRef: maskRef,
      value: value,
      setValue: setValue,
      unmaskedValue: unmaskedValue,
      setUnmaskedValue: setUnmaskedValue,
      typedValue: typedValue,
      setTypedValue: setTypedValue
    };
  }

  Object.defineProperty(exports, 'IMask', {
    enumerable: true,
    get: function () { return IMask__default["default"]; }
  });
  exports.IMaskInput = IMaskInput;
  exports.IMaskMixin = IMaskMixin;
  exports.useIMask = useIMask;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=react-imask.js.map
